(* This file provides the main function for invoking our extraction. *)

From ConCert.Execution Require Import Blockchain.
From ConCert.Execution Require Import Serializable.
From ConCert.Extraction Require Import ClosedAux.
From ConCert.Extraction Require Import Common.
From ConCert.Extraction Require Import Erasure.
From ConCert.Extraction Require Import Optimize.
From ConCert.Extraction Require Import OptimizeCorrectness.
From ConCert.Extraction Require Import ResultMonad.
From ConCert.Extraction Require Import SpecializeChainBase.
From Coq Require Import List.
From Coq Require Import String.
From MetaCoq.Erasure Require Import ELiftSubst.
From MetaCoq.Template Require Import BasicAst.
From MetaCoq.Template Require Import Loader.
From MetaCoq.Template Require Import monad_utils.
From MetaCoq.Template Require Import utils.
From MetaCoq.PCUIC Require Import PCUICAst.
From MetaCoq.PCUIC Require Import PCUICSafeLemmata.
From MetaCoq.PCUIC Require Import PCUICTyping.
From MetaCoq.SafeChecker Require Import PCUICSafeChecker.

Local Open Scope bool.
Local Open Scope string.
Import MonadNotation.

Record dearg_params :=
  { (* If true, trim ends of constant masks to avoid unnecessary eta expansion. *)
    do_trim_const_masks : bool;
    (* If true, trim ends of constructor masks to avoid unnecessary eta expansion. *)
    do_trim_ctor_masks : bool;
    (* Check if erased environment is closed *)
    check_closed : bool;
    (* Check that environment is expanded enough before dearging *)
    check_expanded : bool;
    (* Check that the dearg masks generated by analysis are valid for dearging *)
    check_valid_masks : bool; }.

Record extract_pcuic_params :=
  { (* Function to be used to erase bodies of declarations.
        MetaCoq has both ErasureFunction and SafeErasureFunction.
        The former has the most proofs about it but is not executable from within
        Coq and is less efficient than the latter. The latter uses retyping and is
        executable within Coq, but has some unproved theory about it. *)
    erase_func : forall Σ, ∥wf_ext Σ∥ -> forall Γ t, welltyped Σ Γ t -> typing_result E.term;

    (* Args for dearging (if it should be done) *)
    dearg_args : option dearg_params; }.

Definition extract_pcuic_env
           (params : extract_pcuic_params)
           (Σ : P.global_env) (wfΣ : ∥PT.wf Σ∥)
           (seeds : list kername)
           (ignore : kername -> bool) : result ExAst.global_env string :=

  Σ <- map_error string_of_erase_global_decl_error
                 (erase_global_decls_deps_recursive (erase_func params) Σ wfΣ seeds ignore);;

  match dearg_args params with
  | Some dp =>

    (if check_closed dp && negb (env_closed (trans_env Σ)) then
       Err "Erased environment is not closed"
     else
       Ok tt);;

    let (const_masks, ind_masks) := analyze_env Σ in

    let const_masks := (if do_trim_const_masks dp then trim_const_masks else id) const_masks in
    let ind_masks := (if do_trim_ctor_masks dp then trim_ind_masks else id) ind_masks in

    (if check_expanded dp && negb (is_expanded_env ind_masks const_masks Σ) then
       Err "Erased environment is not expanded enough for dearging to be provably correct"
     else
       Ok tt);;

    (if check_valid_masks dp && negb (valid_masks_env ind_masks const_masks Σ) then
       Err "Analysis produced masks that ask to remove live arguments"
     else
       Ok tt);;

    ret (debox_env_types (dearg_env ind_masks const_masks Σ))
  | None => ret Σ
  end.

Record extract_template_env_params :=
  { (* Function to use to check wellformedness of the environment *)
    check_wf_env_func : forall Σ, result (∥PT.wf Σ∥) string;
    pcuic_args : extract_pcuic_params }.

Definition extract_template_env
           (params : extract_template_env_params)
           (Σ : T.global_env)
           (seeds : list kername)
           (ignore : kername -> bool) : result ExAst.global_env string :=
  let Σ := SafeTemplateChecker.fix_global_env_universes Σ in
  let Σ := T2P.trans_global_decls Σ in
  wfΣ <- check_wf_env_func params Σ;;
  extract_pcuic_env (pcuic_args params) Σ wfΣ seeds ignore.

(* MetaCoq's safe checker does not run from within Coq, only when extracting.
   To work around this we assume environments are well formed when extracting
   from within Coq. This is justified since our environments are produced by quoting
   and thus come directly from Coq, where they have already been type checked. *)
Axiom assume_env_wellformed : forall Σ, ∥PT.wf Σ∥.

(* Extract an environment with some minimal checks. This assumes the environment
   is well-formed (to make it computable from within Coq) but furthermore checks that the
   erased context is closed, expanded and that the masks are valid before dearging.
   Suitable for extraction of programs **from within Coq**. *)
Definition extract_within_coq :=
  {| check_wf_env_func Σ := Ok (assume_env_wellformed Σ);
     pcuic_args :=
       {| erase_func := SafeErasureFunction.erase;
          dearg_args :=
            Some
              {| do_trim_const_masks := true;
                 do_trim_ctor_masks := true;
                 check_closed := true;
                 check_expanded := true;
                 check_valid_masks := true |} |} |}.

Definition extract_template_env_within_coq := extract_template_env extract_within_coq.
