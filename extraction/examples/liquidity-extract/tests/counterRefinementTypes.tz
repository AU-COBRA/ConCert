/***********************************************************************
 File generated by Liquidity compiler version 2.0
 (commit 6472808c, compiled on Wed Sep 16 14:15:26 CEST 2020)
 Date: 2020-09-17 12:02:28
 From file: ./extraction/examples/liquidity-extract/tests/CounterRefinementTypes.liq
 Options:
  - Inlining: true
  - Simplifications: true
  - Peephole optimizations: true
  - Single line output: false
  - Generate annotations: true
  - Uncurrying: true
***********************************************************************/

parameter %main (or :coq_msg (int %Coq_Inc) (int %Coq_Dec));
storage int;
code { DUP ;
       DIP { CDR @st_slash_1 } ;
       CAR @param_slash_2 ;
       LAMBDA @exist_ int int { RENAME @a_slash_27 } ;
       LAMBDA @coq_my_bool_dec
         (pair bool bool)
         (or :coq_sumbool (unit %Coq_left) (unit %Coq_right))
         { RENAME @b1_b2_slash_29 ;
           DUP @b1_b2 ;
           CAR @b1 ;
           IF { LAMBDA
                  bool
                  (or :coq_sumbool (unit %Coq_left) (unit %Coq_right))
                  { RENAME @x_slash_32 ;
                    DUP @x ;
                    IF { PUSH (or :coq_sumbool (unit %Coq_left) (unit %Coq_right)) (Left Unit) }
                       { PUSH (or :coq_sumbool (unit %Coq_left) (unit %Coq_right)) (Right Unit) } ;
                    DIP { DROP } } }
              { LAMBDA
                  bool
                  (or :coq_sumbool (unit %Coq_left) (unit %Coq_right))
                  { RENAME @x_slash_33 ;
                    DUP @x ;
                    IF { PUSH (or :coq_sumbool (unit %Coq_left) (unit %Coq_right)) (Right Unit) }
                       { PUSH (or :coq_sumbool (unit %Coq_left) (unit %Coq_right)) (Left Unit) } ;
                    DIP { DROP } } } ;
           DIP { DUP @b1_b2 } ;
           DIP 2 { DROP } ;
           SWAP ;
           CDR @b2 ;
           EXEC } ;
       LAMBDA @ltInt
         (pair int int)
         bool
         { RENAME @i_j_slash_19 ;
           DUP @i_j ;
           CDR @j ;
           DIP { DUP @i_j } ;
           DIP 2 { DROP } ;
           SWAP ;
           CAR @i ;
           COMPARE ;
           LT } ;
       DIP 2 { DUP @exist_ } ;
       DIG 2 ;
       PAIR ;
       DIP { DUP @coq_my_bool_dec } ;
       SWAP ;
       PAIR ;
       DIP 2 { DUP @exist_ } ;
       DIG 2 ;
       LAMBDA @addInt
         (pair int int)
         int
         { RENAME @i_j_slash_7 ;
           DUP @i_j ;
           CDR @j ;
           DIP { DUP @i_j } ;
           DIP 2 { DROP } ;
           SWAP ;
           CAR @i ;
           ADD } ;
       PAIR ;
       LAMBDA
         (pair (pair int int) (pair (lambda (pair int int) int) (lambda int int)))
         int
         { RENAME @st_inc__addInt_exist__slash_35 ;
           DUP ;
           CDDR @exist__slash_28 ;
           DIP { DUP } ;
           SWAP ;
           CDAR @addInt_slash_10 ;
           DIP 2 { DUP } ;
           DIG 2 ;
           CAR @st_inc_slash_36 ;
           CDR @inc ;
           DIP 3 { DUP } ;
           DIG 3 ;
           DIP 4 { DROP } ;
           CAR @st_inc_slash_36 ;
           CAR @st ;
           PAIR ;
           EXEC ;
           EXEC } ;
       PAIR @coq_inc_counter ;
       PAIR ;
       LAMBDA @subInt
         (pair int int)
         int
         { RENAME @i_j_slash_11 ;
           DUP @i_j ;
           CDR @j ;
           DIP { DUP @i_j } ;
           DIP 2 { DROP } ;
           SWAP ;
           CAR @i ;
           SUB } ;
       DIP 3 { DUP @exist_ } ;
       DIG 3 ;
       PAIR ;
       LAMBDA
         (pair (pair int int) (pair (lambda int int) (lambda (pair int int) int)))
         int
         { RENAME @st_dec__exist__subInt_slash_41 ;
           DUP ;
           CDAR @exist__slash_28 ;
           DIP { DUP } ;
           SWAP ;
           CDDR @subInt_slash_14 ;
           DIP 2 { DUP } ;
           DIG 2 ;
           CAR @st_dec_slash_42 ;
           CDR @dec ;
           DIP 3 { DUP } ;
           DIG 3 ;
           DIP 4 { DROP } ;
           CAR @st_dec_slash_42 ;
           CAR @st ;
           PAIR ;
           EXEC ;
           EXEC } ;
       PAIR @coq_dec_counter ;
       PAIR ;
       LAMBDA
         (pair (pair (or :coq_msg (int %Coq_Inc) (int %Coq_Dec)) int)
               (pair (pair (lambda (pair (pair int int) (pair (lambda int int) (lambda (pair int int) int))) int)
                           (pair (lambda int int) (lambda (pair int int) int)))
                     (pair (pair (lambda (pair (pair int int) (pair (lambda (pair int int) int) (lambda int int))) int)
                                 (pair (lambda (pair int int) int) (lambda int int)))
                           (pair (lambda (pair bool bool) (or :coq_sumbool (unit %Coq_left) (unit %Coq_right)))
                                 (pair (lambda int int) (lambda (pair int int) bool))))))
         (option (pair (list operation) int))
         { RENAME @msg_st__coq_dec_counter_coq_inc_counter_coq_my_bool_dec_exist__ltInt_slash_47 ;
           DUP ;
           CAR @msg_st_slash_48 ;
           CDR @st ;
           DIP { DUP } ;
           SWAP ;
           CAR @msg_st_slash_48 ;
           CAR @msg ;
           IF_LEFT
             { RENAME @i_slash_51 ;
               DIP 2 { DUP } ;
               DIG 2 ;
               CDDDAR @coq_my_bool_dec_slash_34 ;
               PUSH bool True ;
               DIP 4 { DUP } ;
               DIG 4 ;
               CDDDDDR @ltInt_slash_22 ;
               DIP 3 { DUP @i } ;
               DIG 3 ;
               PUSH int 0 ;
               PAIR ;
               EXEC ;
               PAIR ;
               EXEC ;
               IF_LEFT
                 { DROP ;
                   DIP 2 { DUP } ;
                   DIG 2 ;
                   CDDAR @coq_inc_counter_slash_40 ;
                   DIP 3 { DUP } ;
                   DIG 3 ;
                   CDDDDAR @exist__slash_28 ;
                   DIP 2 { DUP @i } ;
                   DIG 2 ;
                   EXEC ;
                   DIP 3 { DUP @st } ;
                   DIG 3 ;
                   PAIR ;
                   DIP { DUP ; CAR ; SWAP ; CDR } ;
                   PAIR ;
                   EXEC ;
                   NIL operation ;
                   PAIR ;
                   SOME }
                 { DROP ; NONE (pair (list operation) int) } ;
               DIP { DROP } }
             { RENAME @i_slash_53 ;
               DIP 2 { DUP } ;
               DIG 2 ;
               CDDDAR @coq_my_bool_dec_slash_34 ;
               PUSH bool True ;
               DIP 4 { DUP } ;
               DIG 4 ;
               CDDDDDR @ltInt_slash_22 ;
               DIP 3 { DUP @i } ;
               DIG 3 ;
               PUSH int 0 ;
               PAIR ;
               EXEC ;
               PAIR ;
               EXEC ;
               IF_LEFT
                 { DROP ;
                   DIP 2 { DUP } ;
                   DIG 2 ;
                   CDAR @coq_dec_counter_slash_46 ;
                   DIP 3 { DUP } ;
                   DIG 3 ;
                   CDDDDAR @exist__slash_28 ;
                   DIP 2 { DUP @i } ;
                   DIG 2 ;
                   EXEC ;
                   DIP 3 { DUP @st } ;
                   DIG 3 ;
                   PAIR ;
                   DIP { DUP ; CAR ; SWAP ; CDR } ;
                   PAIR ;
                   EXEC ;
                   NIL operation ;
                   PAIR ;
                   SOME }
                 { DROP ; NONE (pair (list operation) int) } ;
               DIP { DROP } } ;
           DIP { DROP 2 } } ;
       PAIR @coq_counter ;
       DIP 4 { DUP @st } ;
       DIG 4 ;
       DIP 4 { DUP @param } ;
       DIG 4 ;
       PAIR ;
       PAIR ;
       DUP ;
       CDR @coq_counter_slash_55 ;
       DIP { DUP } ;
       SWAP ;
       CAR @param_st_slash_57 ;
       CDR @st ;
       DIP 2 { DUP } ;
       DIG 2 ;
       CAR @param_st_slash_57 ;
       CAR @param ;
       PAIR ;
       DIP { DUP ; CAR ; SWAP ; CDR } ;
       PAIR ;
       EXEC ;
       IF_NONE { UNIT ; FAILWITH } {} ;
       DIP { DROP 5 } };
